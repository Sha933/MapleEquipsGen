<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: 'Arial', sans-serif;
      /* You can use a generic font family like 'sans-serif' as a fallback. */
    }
  </style>
</head>
</head>
<body>
  <canvas id="myCanvas" width="234" height="310"></canvas>
  <canvas id="onlyBackgroundCanvas" width="234" height="310"></canvas>
</br>
  

<!-- Textbox -->
<h2>STEP 1: Load Image + Name</h2>
<p>Go to <a href="https://maplestory.wiki/GMS/207.1.1/item?overallCategory=Equip&page=1&category=Armor&subCategory=Bottom">MapleStory.wiki</a> and search for your item.</a>
</br>
Copy the ID from the URL to the following text box.
</p>
<img src="tutorial1.png" height=""/>
<br>
<label>Item ID:</label>
<input type="text" id="myTextbox" placeholder="Enter text" value="1332023">
<!-- Button -->
<button onclick="loadData()">Load Data</button>

<br>
<br>
<h2>STEP 2: Modify Title</h2>
<table>
  <tr>
    <td><Label style="margin-right: 10px;">Applied Scrolls:</Label></td>
    <td><input id="appliedScrolls" value="(+5)"  oninput="redraw()"></td>
  </tr>
  <tr hidden>
    <td><Label>Item title:</Label></td>
    <td><input id="title" value="Placeholder" oninput="redraw()"></td>
  </tr>
  <tr>
    <td><Label>Item title color:</Label></td>
    <td><input id="titleColor" value="yellow"  oninput="redraw()"></td>
    <tr>
      <td colspan="2">
      <label style="font-size: 11px"> Possible Values (css syntax): "yellow", "white", rgba(100,255,255), #FF6600 ...</label>
      </td>
    </tr>
  </tr>
  <tr>
    <td><Label>Owner Name (Item tag):</Label></td>
    <td><input id="owner" value="" oninput="redraw()"></td>
  </tr>
  <tr>
    <td><Label>Star Force:</Label></td>
    <td><input id="starforce" value="0" oninput="redraw()"></td>
  </tr>
</table>

<div hidden>
  <br>
  <!-- Textbox 1 -->
  <label for="reqLevelEquip">REQ Level:</label>
  <input type="text" id="reqLevelEquip" value=""/>
  <br>

  <!-- Textbox 2 -->
  <label for="reqSTR">REQ STR:</label>
  <input type="text" id="reqSTR" value=""/>
  <br>

  <!-- Textbox 3 -->
  <label for="reqDEX">REQ DEX:</label>
  <input type="text" id="reqDEX" value=""/>
  <br>

  <!-- Textbox 4 -->
  <label for="reqINT">REQ INT:</label>
  <input type="text" id="reqINT" value=""/>
  <br>

  <!-- Textbox 5 -->
  <label for="reqLUK">REQ LUK:</label>
  <input type="text" id="reqLUK" value=""/>
  <br>
</div>


<h3>STEP 3: Modify Potential</h3>
  <label><input type="radio" name="rarity" value="none" checked oninput="redraw()">(none)</label> 
  <label><input type="radio" name="rarity" value="hidden" oninput="redraw()"> Hidden</label>
  <label><input type="radio" name="rarity" value="rare" oninput="redraw()" checked> Rare</label>
  <label><input type="radio" name="rarity" value="unique" oninput="redraw()"> Unique</label>
  <label><input type="radio" name="rarity" value="epic" oninput="redraw()"> Epic</label>
  <label><input type="radio" name="rarity" value="legendery" oninput="redraw()"> Legendery</label>
<br>

<h3>STEP 4: Modify special coditions</h3>
<input type="checkbox" id="oneOfKind" oninput="redraw()">
<label for="oneOfKind">One of a kind</label>
<br>
<input type="checkbox" id="untradeable" oninput="redraw()">
<label for="untradeable">Untradeable</label>
<br>
<input type="checkbox" id="uniqueEquipped" oninput="redraw()">
<label for="uniqueEquipped">Unique Equipped</label>


<h2>STEP 5: Set allowed classes</h2>
<input type="checkbox" checked id="beginner" oninput="redraw()">
<label for="beginner">Beginner</label>
<input type="checkbox" checked id="warrior" oninput="redraw()">
<label for="warrior">Warrior</label>
<input type="checkbox" checked id="magician" oninput="redraw()">
<label for="magician">Magician</label>
<input type="checkbox" checked id="bowman" oninput="redraw()">
<label for="bowman">Bowman</label>
<input type="checkbox" checked id="thief" oninput="redraw()">
<label for="thief">Thief</label>
<input type="checkbox" checked id="pirate" oninput="redraw()">
<label for="pirate">Pirate</label>


<h2>STEP 6: Modify Details</h2>
<div class="input-pair-container">
  <span class="input-pair">
    <input type="text" size="40" class="label-input" value="---"  readonly  oninput="redraw()" style="background-color: gainsboro;">
    <input type="text" id="category" value="" class="value-input" oninput="redraw()">
  </span>
  <br>
  <span class="input-pair">
    <input type="text" size="40" id="categoryLabel" class="label-input" value="CATEGORY" oninput="redraw()">
    <input type="text" id="category" value="DAGGER" class="value-input" oninput="redraw()">
  </span>
  <br>
  <span class="input-pair">
    <input type="checkbox" checked id="attackSpeedCheckbox"  class="checkbox-input"  oninput="redraw()">
    <input type="text" size="40" id="attackSpeedLabel" class="label-input" value="ATTACK SPEED" oninput="redraw()">
    <input type="text" id="attackSpeed" value="FAST" class="value-input" oninput="redraw()">
  </span>
  <br>
  <span class="input-pair">
  <input type="checkbox" unchecked id="strCheckbox"  class="checkbox-input"  oninput="redraw()">
  <input type="text" size="40" id="strLabel" class="label-input" value="STR" oninput="redraw()">
  <input type="text" id="str" value="+25" class="value-input" oninput="redraw()">
  </span>
  <br>
  <span class="input-pair">
  <input type="checkbox" checked id="dexCheckbox"  class="checkbox-input"  oninput="redraw()">
  <input type="text" size="40" id="dexLabel" class="label-input" value="DEX" oninput="redraw()">
  <input type="text" id="dex" value="+1" class="value-input" oninput="redraw()">
</span>
  <br>
  <span class="input-pair">
  <input type="checkbox" unchecked id="intCheckbox"  class="checkbox-input"  oninput="redraw()">
  <input type="text" size="40" id="intLabel" class="label-input" value="INT" oninput="redraw()">
  <input type="text" id="int" value="+1" class="value-input" oninput="redraw()">
</span>
<br>
<span class="input-pair">
<input type="checkbox" checked id="lukCheckbox"  class="checkbox-input"  oninput="redraw()">
<input type="text" size="40" id="lukLabel" class="label-input" value="LUK" oninput="redraw()">
<input type="text" id="int" value="+9" class="value-input" oninput="redraw()">
</span>
<br>
<span class="input-pair">
<input type="checkbox" unchecked id="hpCheckbox"  class="checkbox-input"  oninput="redraw()">
<input type="text" size="40" id="hpLabel" class="label-input" value="HP" oninput="redraw()">
<input type="text" id="int" value="10%" class="value-input" oninput="redraw()">
</span>
  <br>
  <span class="input-pair">
  <input type="checkbox" unchecked id="mpCheckbox"  class="checkbox-input"  oninput="redraw()">
  <input type="text" size="40" id="mpLabel" class="label-input" value="MP" oninput="redraw()">
  <input type="text" id="int" value="10%" class="value-input" oninput="redraw()">
  </span>
  <br>
  <span class="input-pair">
  <input type="checkbox" checked id="weaponAttackCheckbox"  class="checkbox-input"  oninput="redraw()">
  <input type="text" size="40" id="weaponAttackLabel" class="label-input" value="WEAPON ATTACK" oninput="redraw()">
  <input type="text" id="weaponAttack" value="114" class="value-input" oninput="redraw()">
</span>
<br>
<span class="input-pair">
<input type="checkbox" unchecked id="magicAttackCheckbox"  class="checkbox-input"  oninput="redraw()">
<input type="text" size="40" id="magicAttackLabel" class="label-input" value="MAGIC ATTACK" oninput="redraw()">
<input type="text" id="magicAttack" value="20" class="value-input" oninput="redraw()">
</span>
  <br>
  <span class="input-pair">
  <input type="checkbox" checked id="weaponDefCheckbox"  class="checkbox-input"  oninput="redraw()">
  <input type="text" size="40" id="weaponDefLabel" class="label-input" value="WEAPON DEF" oninput="redraw()">
  <input type="text" id="weaponDef" value="1" class="value-input" oninput="redraw()">
</span>
  <br>
  <span class="input-pair">
  <input type="checkbox" unchecked id="magicDefCheckbox"  class="checkbox-input"  oninput="redraw()">
  <input type="text" size="40" id="magicDefLabel" class="label-input" value="MAGIC DEF" oninput="redraw()">
  <input type="text" id="magicDef" value="60" class="value-input" oninput="redraw()">
</span>
  <br>
  <span class="input-pair">
  <input type="checkbox" checked id="accuracyCheckbox"  class="checkbox-input"  oninput="redraw()">
  <input type="text" size="40" id="accuracyLabel" class="label-input" value="ACCURACY" oninput="redraw()">
  <input type="text" id="accuracy" value="+2" class="value-input" oninput="redraw()">
</span>
  <br>
  <span class="input-pair">
  <input type="checkbox" unchecked id="avoidabilityCheckbox"  class="checkbox-input"  oninput="redraw()">
  <input type="text" size="40" id="avoidabilityLabel" class="label-input" value="AVOIDABILITY" oninput="redraw()">
  <input type="text" id="avoidability" value="+20" class="value-input" oninput="redraw()">
</span>
<br>
<span class="input-pair">
<input type="checkbox" checked id="upgradesAvailableCheckbox"  class="checkbox-input"  oninput="redraw()">
<input type="text" size="40" id="upgradesAvailableLabel" class="label-input" value="NUMBER OF UPGRADES AVAILABLE" oninput="redraw()">
<input type="text" id="upgradesAvailable" value="0" class="value-input" oninput="redraw()">
</span>
<br>
<span class="input-pair">
<input type="checkbox" checked id="hammersAppliedCheckbox"  class="checkbox-input"  oninput="redraw()">
<input type="text" size="40" id="hammersAppliedLabel" class="label-input" value="NUMBER OF VICIOUS' HAMMER APPLIED" oninput="redraw()">
<input type="text" id="hammersApplied" value="2" class="value-input" oninput="redraw()">
</span>
<br>
<span class="input-pair">
<input type="checkbox" checked id="potentialSectionSeparatorCheckbox" class="checkbox-input"  oninput="redraw()">
<input type="text" size="40" id="potentialSectionSeparatorLabel" class="label-input" value="---" oninput="redraw()">
<input type="text" id="potentialSectionSeparator" value="" class="value-input" oninput="redraw()">
</span>
<br>
<span class="input-pair">
<input type="checkbox" checked id="accuracyPotentialCheckbox"  class="checkbox-input"  oninput="redraw()">
<input type="text" size="40" id="accuracyPotentialLabel" class="label-input" value="ACCURACY" oninput="redraw()">
<input type="text" id="accuracyPotential" value="+16" class="value-input" oninput="redraw()">
</span>
<br>
<span class="input-pair">
<input type="checkbox" checked id="avoidabilityPotentialCheckbox"  class="checkbox-input"  oninput="redraw()">
<input type="text" size="40" id="avoidabilityPotentialLabel" class="label-input" value="AVOIDABILITY" oninput="redraw()">
<input type="text" id="avoidabilityPotential" value="+16" class="value-input" oninput="redraw()">
</span>
</div>


<h2>STEP 7 (Optional): Change size</h2>

<label>Scale:</label>
<input type="text" id="scaleBox" value="1" oninput="redraw()">
</br>

<h2>STEP 8: Save</h2>
<div>
<p>Click the checkbox to enable saving:</p>
  <input type="checkbox" id="split" oninput="splitReload()">
  <label for="split">Split background from other elements</label>
</div>
</br>
<button id="saveButton" disabled>Save Background + Foreground</button>

<script>

    function splitReload() {
      document.getElementById("saveButton").disabled = !document.getElementById("split").checked;
      loadData()
    }

  document.addEventListener("DOMContentLoaded", function() {

    // Get the save button element
    var saveButton = document.getElementById("saveButton");

    // Add click event listener to the save button
    saveButton.addEventListener("click", function() {
      // Get the canvas element and its 2d context
      var canvas = document.getElementById("myCanvas");
      let backGroundcanvas = document.getElementById("onlyBackgroundCanvas");
      document.getElementById("split").checked = true;
      // Get the data URL of the canvas
      var dataURL = canvas.toDataURL("image/png");

      // Create a link element
      var link = document.createElement("a");

      // Set the href attribute of the link to the data URL
      link.href = dataURL;

      // Set the download attribute with a desired filename
      link.download = "foreground.png";

      // Append the link to the document
      document.body.appendChild(link);

      // Trigger a click on the link to start the download
      link.click();

      // Remove the link from the document
      document.body.removeChild(link);
      
      // Get the data URL of the canvas
      var dataURL = backGroundcanvas.toDataURL("image/png");

      // Create a link element
      var link = document.createElement("a");

      // Set the href attribute of the link to the data URL
      link.href = dataURL;

      // Set the download attribute with a desired filename
      link.download = "background.png";

      // Append the link to the document
      document.body.appendChild(link);

      // Trigger a click on the link to start the download
      link.click();

      // Remove the link from the document
      document.body.removeChild(link);

      
      //document.getElementById("split").checked = false;
    });
  });
</script>


  <script>
    let starImage = new Image();
    starImage.src = 'star.png';

    let stat = [];
    count_stat = 0;
    const loadStatDigits = () => {
      return new Promise((resolve, reject) => {
        stat_plus = new Image();
        stat_plus.onload = () => {
          count_stat += 1;
          console.error("count_stat:" + count_stat);
          if (count_stat == 12)
            resolve()
        }
        stat_plus.src = 'stat_plus.png';
        
        stat_percent = new Image();
        stat_percent.onload = () => {
          count_stat += 1;
          console.error("count_stat:" + count_stat);
          if (count_stat == 12)
            resolve()
        }
        stat_percent.src = 'stat_percent.png';
        for (let i = 0; i <= 9; i++) {
            let image = new Image();
            image.onload = () => {
              count_stat += 1;
              if (count_stat == 12)
                resolve()
            }
            image.src = `stat_${i}.png`;
            stat.push(image);
        }
      })
    };

    let req = [];
    count = 0;
    const loadReqDigits = () => {
      return new Promise((resolve, reject) => {
        req_dash = new Image();
        req_dash.onload = () => {
          count += 1;
          console.error("COUNT:" + count);
          if (count == 11)
            resolve()
        }
        req_dash.src = 'req_dash.png';
        for (let i = 0; i <= 9; i++) {
            let image = new Image();
            image.onload = () => {
              count += 1;
              if (count == 11)
                resolve()
            }
            image.src = `req_${i}.png`;
            req.push(image);
        }
      })
    };

    function get_yes_no(element_id) {
      return document.getElementById(element_id).checked ? "y" : "n";
    }

    function get_rarity() {
      var selectedRarity = document.querySelector('input[name="rarity"]:checked').value;
      var result = "";

      if (selectedRarity === "hidden") {
        result = "(Hidden Potential Item)";
      } else if (selectedRarity === "rare") {
        result = "(Rare Item)";
      } else if (selectedRarity === "unique") {
        result = "(Unique Item)";
      } else if (selectedRarity === "epic") {
        result = "(Epic Item)";
      } else if (selectedRarity === "legendery") {
        result = "(Legendery Item)";
      }
      
      return result;
    }
    function get_rarity_text_color() {
      var selectedRarity = document.querySelector('input[name="rarity"]:checked').value;
      var result = "";

      result = "white";
      if (selectedRarity === "hidden") {
        result = "#FF0066";
      }
      return result;
    }
    
    function get_rarity_border_color() {
      var selectedRarity = document.querySelector('input[name="rarity"]:checked').value;
      var result = "";

      if (selectedRarity === "hidden") {
        result = "#FF0066";
      } else if (selectedRarity === "rare") {
        result = "#55AAFF";
      } else if (selectedRarity === "unique") {
        result = "#FFCC00";
      } else if (selectedRarity === "epic") {
        result = "#CC66FF";
      } else if (selectedRarity === "legendery") {
        result = "#00FF00";
      }
      
      return result;
    }

    let required_str = 0;

    
    function setClassesCheckboxes(bitmask) {
        if (bitmask == 0 || bitmask == undefined)
        {
          document.getElementById("beginner").checked = true;
          bitmask = 0xffff;
        }
        else {
          document.getElementById("beginner").checked = false;
        }
        // List of checkbox IDs
        const checkboxIds = ['warrior', 'magician', 'bowman', 'thief', 'pirate'];

        // Loop through each checkbox
        for (let i = 0; i < checkboxIds.length; i++) {
          const checkboxId = checkboxIds[i];
          // Check if the corresponding bit is set in the bitmask
          const isBitSet = (bitmask & (1 << i)) !== 0;
          // Update the checkbox state based on the bitmask
          document.getElementById(checkboxId).checked = isBitSet;
        }
      }

    var itemImagePromise;
    function loadItemImageAsync(url) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "Anonymous";

        // Event handler for successful image loading
        img.onload = function () {
            console.error("Got item's image back from MS.io!");
            resolve(img);
        };

        // Event handler for image loading errors
        img.onerror = function () {
            console.error("Failed to load the item's image.");
            reject(new Error("Image loading failed."));
        };

        img.src = url;
      });
    }


    function updateFieldsFromJson(megaJson) {
      // Now after the background (blueish) and item-background (gray)
      // are drawn, we can try to get the image from that other MS website
      let imageUrl = 'https://maplestory.io/api/GMS/207.1.1/item/'+ megaJson.id +'/icon?resize=2'; // Replace with the path to your image
      itemImagePromise = loadItemImageAsync(imageUrl)

      document.getElementById("title").value = megaJson.description.name;
      
      console.error("megaJson.metaInfo.reqJob === " + megaJson.metaInfo.reqJob);
      setClassesCheckboxes(megaJson.metaInfo.reqJob);

      function setFieldValueById(fieldId, value) {
          var fieldElement = document.getElementById(fieldId);

          // Check if the element exists
          if (fieldElement) {
              // Set the value of the element
              fieldElement.value = value;
          } else {
              // Handle the absence of the element as needed
              console.error("Element with ID '" + fieldId + "' not found.");
          }
      }

      // Copy values from megaJson properties to corresponding textboxes
      setFieldValueById('reqLevelEquip', megaJson.metaInfo.reqLevelEquip);
      setFieldValueById('reqSTR', megaJson.metaInfo.reqSTR);
      setFieldValueById('reqDEX', megaJson.metaInfo.reqDEX);
      setFieldValueById('reqINT', megaJson.metaInfo.reqINT);
      setFieldValueById('reqLUK', megaJson.metaInfo.reqLUK);
    }



















    function redraw() {
        console.error("myFunction entered!");
        const canvas = document.getElementById("myCanvas");
        let backGroundcanvas = document.getElementById("myCanvas");
        if (document.getElementById("split").checked)
        {
          backGroundcanvas = document.getElementById("onlyBackgroundCanvas");
        }
        let ctx = canvas.getContext("2d");
        let backgroundCtx = backGroundcanvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        backgroundCtx.clearRect(0, 0, canvas.width, canvas.height);
        let modifier = parseFloat(document.getElementById("scaleBox").value);
        if (isNaN(modifier)) {
            modifier = 1;
        }
        
        function renderReqNumber(number, context, x, y) {
            // Check if the number is 0 or undefined
            if (number == 0 || number === undefined) {
                // Draw the dash image at the specified location
                context.drawImage(req_dash, x, y, req_dash.naturalWidth * modifier, req_dash.naturalHeight * modifier);
                return;
            }

            // Convert the number to a string to access each digit
            const numberStr = number.toString();
            // Iterate through each digit and render the corresponding image
            for (let i = 0; i < numberStr.length; i++) {
                // Get the digit at the current position
                const digit = parseInt(numberStr[i]);

                // Check if the digit is a valid index in the req array
                if (!isNaN(digit) && digit >= 0 && digit <= 9) {
                    // Draw the image at the specified location
                    context.drawImage(req[digit], 
                    x, 
                    y, 
                    req[digit].naturalWidth * modifier, 
                    req[digit].naturalHeight * modifier);
                    // Adjust the positioning based on your requirements
                }
                x += req[digit].naturalWidth * modifier
                x += 1 * modifier; // one pixel padding between digits
            }
        }

        function containsOnlyAllowedChars(inputString) {
          // Define a regular expression that matches only digits, plus sign, and percent sign
          var regex = /^[+]?[0-9]+%?$/;

          // Test if the input string matches the regular expression
          return regex.test(inputString);
        }

        function renderStatValue(value, context, x, y) {
          if (!containsOnlyAllowedChars(value)) {
                return false;
          }

          // Fix pixel-allignment drawing
          let pixelWidth = 1 * modifier;
          //ctx.translate(pixelWidth/2, 0);


          // Convert the number to a string to access each digit
          const numberStr = value.toString();
          // Iterate through each digit and render the corresponding image
          for (let i = 0; i < numberStr.length; i++) {
              // Get the digit at the current position
              next_char = numberStr[i]
              if (next_char == "+") {
                context.drawImage(stat_plus, x, y, stat_plus.naturalWidth * modifier, stat_plus.naturalHeight * modifier);
                x += stat_plus.naturalWidth * modifier
                x += 2 * modifier; // one pixel padding between digits
                continue;
              }
              if (next_char == "%") {
                context.drawImage(stat_percent, x, y, stat_percent.naturalWidth * modifier, stat_percent.naturalHeight * modifier);
                x += stat_percent.naturalWidth * modifier
                x += 2 * modifier; // one pixel padding between digits
                continue;
              }

              const digit = parseInt(next_char);

              // Check if the digit is a valid index in the req array
              if (!isNaN(digit) && digit >= 0 && digit <= 9) {
                  // Draw the image at the specified location
                  context.drawImage(stat[digit], 
                  x, 
                  y, 
                  stat[digit].naturalWidth * modifier, 
                  stat[digit].naturalHeight * modifier);
                  // Adjust the positioning based on your requirements
              }
              x += stat[digit].naturalWidth * modifier
              x += 2 * modifier; // one pixel padding between digits
          }

          // Undo previous 'translate'
          //ctx.translate(-pixelWidth/2, 0);
          return true;
        }

        let bgn_file = "bgn_" + get_yes_no("beginner") + ".png"
        let war_file = "war_" + get_yes_no("warrior") + ".png"
        let mag_file = "mag_" + get_yes_no("magician") + ".png"
        let bow_file = "bow_" + get_yes_no("bowman") + ".png"
        let thi_file = "thi_" + get_yes_no("thief") + ".png"
        let pir_file = "pir_" + get_yes_no("pirate") + ".png"
        function do_classes(offset) {
          let y_off = offset;
          const characters = [
            { name: 'BEGINNER', file: bgn_file, x: 10, y: y_off },
            { name: 'WARRIOR', file: war_file, x: 52, y: y_off },
            { name: 'MAGICIAN', file: mag_file, x: 92, y: y_off },
            { name: 'BOWMAN', file: bow_file, x: 132, y: y_off },
            { name: 'THIEF', file: thi_file, x: 171, y: y_off },
            { name: 'PIRATE', file: pir_file, x: 197, y: y_off },
          ];

          ctx.imageSmoothingEnabled = false;
          characters.forEach(character => {
            const img = new Image();
            img.src = character.file;
            img.onload = function() {
              ctx.drawImage(
                img,
                character.x * modifier,
                character.y,
                img.width * modifier,
                img.height * modifier
              );
            };
          });
        }

        function drawPixelArtBorder(ctx, x0, y0, width, height) {
          // Draw outer border
          x1 = x0 + width;
          y1 = y0 + height
          ctx.imageSmoothingEnabled = false;
          // Draw blank pixels at each corner
          // Undoing previous half-pixel alighnment for other drawing to work as expected
          let pixelWidth = 1 * modifier;
          let pixelHeight = 1 * modifier;
          ctx.translate(pixelWidth/2, pixelWidth/2);
          ctx.lineWidth = pixelWidth;
          ctx.strokeRect(x0, y0, x1 - x0, y1 - y0);

          ctx.strokeRect(x0 + pixelWidth, y0 + pixelWidth, pixelWidth, pixelHeight); // Top-left corner
          ctx.strokeRect(x1 - ( 2 * pixelWidth), y0 + pixelWidth, pixelWidth, pixelHeight); // Top-right corner
          ctx.strokeRect(x0 + pixelWidth, y1 - ( 2 * pixelWidth), pixelWidth, pixelHeight); // Bottom-left corner
          ctx.strokeRect(x1 - ( 2 * pixelWidth), y1 - ( 2 * pixelWidth), pixelWidth, pixelHeight); // Bottom-right corner.

          ctx.translate(-pixelWidth/2, -pixelWidth/2);

           // Top-left corner
          ctx.clearRect(x0, y0, pixelWidth, pixelHeight);
          ctx.clearRect(x0+(2 * modifier), y0+(2 * modifier), pixelWidth, pixelHeight);
          ctx.clearRect(x0+ (1 * modifier), y0+(2 * modifier), pixelWidth, pixelHeight);
          ctx.clearRect(x0+(2 * modifier), y0+ (1 * modifier), pixelWidth, pixelHeight);

          // Top-right corner
          ctx.clearRect(x1, y0, pixelWidth, pixelHeight);
          ctx.clearRect(x1-(2 * modifier), y0+(2 * modifier), pixelWidth, pixelHeight);
          ctx.clearRect(x1- (1 * modifier), y0+(2 * modifier), pixelWidth, pixelHeight);
          ctx.clearRect(x1-(2 * modifier), y0+ (1 * modifier), pixelWidth, pixelHeight);

          // Bottom-left corner
          ctx.clearRect(x0, y1, pixelWidth, pixelHeight);
          ctx.clearRect(x0+(2 * modifier), y1-(2 * modifier), pixelWidth, pixelHeight);
          ctx.clearRect(x0+ (1 * modifier), y1-(2 * modifier), pixelWidth, pixelHeight);
          ctx.clearRect(x0+(2 * modifier), y1- (1 * modifier), pixelWidth, pixelHeight);

          // Bottom-right corner
          ctx.clearRect(x1, y1, pixelWidth, pixelHeight);
          ctx.clearRect(x1-(2 * modifier), y1-(2 * modifier), pixelWidth, pixelHeight);
          ctx.clearRect(x1- (1 * modifier), y1-(2 * modifier), pixelWidth, pixelHeight);
          ctx.clearRect(x1-(2 * modifier), y1- (1 * modifier), pixelWidth, pixelHeight);2
        }

        ctx.imageSmoothingEnabled = false;
        var x = 1 * modifier;
        var y = 1 * modifier;
        var radius = 2;

        // Item Name
        let fontSize = 12  * modifier;
        var titleColor = document.getElementById("titleColor").value;


        let offset = 0;

        // Star Force upgrades
        let starforceCount = parseInt(document.getElementById("starforce").value);
        if (starforceCount > 0) {
          starforceY_offset = offset;
          offset += 18 * modifier;
        }
        

        // Owner Name (Item Tag)
        let ownerText = document.getElementById("owner").value;
        if (ownerText != "") {
          ownerTextY_offset = offset;
          offset += 18 * modifier;
        }

        var appliedScrolls = document.getElementById("appliedScrolls").value;
        let itemNameText = document.getElementById("title").value +" " + appliedScrolls;
        let itemNameTextY = offset + (22 * modifier);
        var blueDotCenterY = offset + (17 * modifier);
        let itemNameTextX = 18 * modifier;
        offset += 17 * modifier;


        // Orange Modifiers
        let rarityText = get_rarity();
        rarityTextY_offset = offset;
        if (rarityText != "") {
          offset += 17 * modifier;
        }
        

        // Orange Modifiers
        let orangeModifiersText = "";
        if (document.getElementById("oneOfKind").checked) {
          orangeModifiersText += "One-of-a-kind Item";
        }
        if (document.getElementById("untradeable").checked) {
          if (orangeModifiersText != "")
            orangeModifiersText += ", "
          orangeModifiersText += "Untradeable";
        }
        if (document.getElementById("uniqueEquipped").checked) {
          if (orangeModifiersText != "")
            orangeModifiersText += ", "
          orangeModifiersText += "Unique Equipped Item";
        }
        orangeModifiersTextY_offset = offset;
        if (orangeModifiersText != "") {
          offset += 17 * modifier;
        }

        // Text information array
        var textLines = composeFields()

        var separatorLinesCount = textLines.filter(obj => obj.label && obj.label.startsWith("---")).length;
        var nonSeparatorLinesCount = textLines.length - separatorLinesCount;
        totalDynamicLengths = (nonSeparatorLinesCount * 13 * modifier) +
                              (separatorLinesCount * 6 * modifier) +
                               offset;


        // -------------> ACTUAL DRAWING STARTS HERE <---------------------
        // BLUE BORDER
        canvas.width = 236 * modifier;
        canvas.height = (149 * modifier) + totalDynamicLengths;
        onlyBackgroundCanvas.width = 236 * modifier;
        onlyBackgroundCanvas.height = (149 * modifier) + totalDynamicLengths;
        backgroundCtx.strokeStyle = 'rgba(53, 59, 129, 0.86)';
        drawPixelArtBorder(backgroundCtx, 0, 0, canvas.width - (1 * modifier), canvas.height - (1 * modifier))
        
        // Thin WHITE BORDER between blue parts
        backgroundCtx.strokeStyle = 'white';
        let pixelWidth = 1 * modifier;
        let pixelHeight = 1 * modifier;
        backgroundCtx.translate(pixelWidth/2, pixelWidth/2);
        backgroundCtx.strokeRect(2 * modifier, 1 * modifier,canvas.width - (5 * modifier), 0)
        backgroundCtx.strokeRect(1 * modifier, 2 * modifier,0, canvas.height - (5 * modifier))
        backgroundCtx.strokeRect(2 * modifier,canvas.height - (2 * modifier), canvas.width - (5 * modifier), 0)
        backgroundCtx.strokeRect(canvas.width - (2 * modifier), 2 * modifier, 0, canvas.height - (5 * modifier))
        backgroundCtx.translate(-pixelWidth/2, -pixelWidth/2);
        

        // BLUE BACKGROUND
        backgroundCtx.fillStyle = 'rgba(53, 59, 129, 0.86)';
        backgroundCtx.fillRect(2 * modifier, 2 * modifier, canvas.width - (4 * modifier),canvas.height - (4 * modifier)); 

        // ITEM NAME
        ctx.fillStyle = titleColor;
        ctx.font = `${fontSize}px Arial`;
        ctx.fillText(itemNameText, itemNameTextX, itemNameTextY);

        // Draw small blue dot next to item name
        var centerX = 13 * modifier;
        var centerY = blueDotCenterY;
        radius = 2.3 * modifier;
        var fillColor = "#55CCFF";
        // Draw the circle
        ctx.translate(-0.5, +0.5);
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
        ctx.fillStyle = fillColor;
        ctx.fill();
        ctx.closePath();
        ctx.translate(+0.5, -0.5);

        // STAR FORCE UPGRADES
        if (starforceCount > 0) {
          starforceY = starforceY_offset + (10 * modifier);
          totalWidth = starImage.width * modifier * starforceCount;
          starforceX = (canvas.width/2) - totalWidth/2;
          console.log("[STAR FORCE] totalWidth: " + totalWidth);
          console.log("[STAR FORCE] (canvas.width/2): " + (canvas.width/2));
          console.log("[STAR FORCE] starforceX: " + starforceX);
          currX = starforceX;
          for (let i = 0; i < starforceCount; i++) {
            ctx.drawImage(starImage, currX, starforceY);
            currX += starImage.width * modifier;
          }
        }

        // OWNER NAME
        if (ownerText != "") {
          ctx.fillStyle = '#FF8811';
          ctx.font = `bold ${fontSize}px Arial`;
          ownerTextX = (canvas.width/2);
          ownerTextY = ownerTextY_offset + (22 * modifier);
          let lengthWithApo = ctx.measureText(ownerText +"'s").width;
          let lengthWithoutApo = ctx.measureText(ownerText).width + (1 * modifier);
          ctx.fillText(ownerText, ownerTextX - (lengthWithApo/2), ownerTextY);
          ctx.fillStyle = 'white';
          ctx.fillText("'s", ownerTextX - (lengthWithApo/2) + lengthWithoutApo, ownerTextY);
        }

        // ITEM POTENTIAL
        if (rarityText != "") {
          ctx.fillStyle = get_rarity_text_color();
          ctx.font = `${fontSize}px Arial`;
          rarityTextX = (canvas.width/2);
          rarityTextY = rarityTextY_offset + (22 * modifier);
          let rarityLength = ctx.measureText(rarityText).width;
          ctx.fillText(rarityText, rarityTextX - (rarityLength/2), rarityTextY);

          // DRAW POTENTIAL BORDER
          ctx.strokeStyle = get_rarity_border_color();
          let pixelWidth = 1 * modifier;
          let pixelHeight = 1 * modifier;
          ctx.translate(pixelWidth/2, pixelWidth/2);
          ctx.strokeRect(4 * modifier, 4 * modifier,canvas.width - (9 * modifier), 0)
          ctx.strokeRect(4 * modifier, 4 * modifier,0, canvas.height - (9 * modifier))
          ctx.strokeRect(4 * modifier,canvas.height - (5 * modifier), canvas.width - (9 * modifier), 0)
          ctx.strokeRect(canvas.width - (5 * modifier), 4 * modifier, 0, canvas.height - (9 * modifier))
          ctx.translate(-pixelWidth/2, -pixelWidth/2);

        }
        
        // ORANGE TEXT MODIFIERS (Untradable, ...)
        if (orangeModifiersText != "") {
          ctx.fillStyle = 'orange';
          ctx.font = `${fontSize}px Arial`;
          orangeModifiersTextX = (canvas.width/2);
          orangeModifiersTextY = orangeModifiersTextY_offset + (22 * modifier);
          let specialConfitionsLength = ctx.measureText(orangeModifiersText).width;
          ctx.fillText(orangeModifiersText, orangeModifiersTextX - (specialConfitionsLength/2), orangeModifiersTextY);
        }


        // Item's Image GRAY BOX BACKGROUND
        ctx.fillStyle = 'rgba(255, 255, 255, 0.66)'; // Set the fill color
        ctx.fillRect(/* x */ 10 * modifier,
                    /* y */ offset + (15 * modifier),
                    68 * modifier,
                    68 * modifier); 
          
        // REQUIRED STATS BLOCK
        let statsImage = new Image();
        statsImage.src = 'stats.png';
        statsImage.onload = function() { 
            ctx.drawImage(statsImage, 
              /* x */ 94 * modifier,
              /* y */ offset + (15 * modifier), 
              statsImage.width * modifier,
              statsImage.height * modifier);
        }
        
        function getFieldValueById(fieldId) {
            // Fetch the element with the specified ID
            var fieldElement = document.getElementById(fieldId);

            // Check if the element exists
            if (fieldElement) {
                // Return the value of the element
                return fieldElement.value;
            } else {
                // Return a default value or handle the absence of the element
                return '';
            }
        }

        // REQ LEVEL
        req_offset = offset
        // Use the getFieldValueById function to get values from specific fields
        renderReqNumber(getFieldValueById('reqLevelEquip'), ctx, 
              /* x */ 144 * modifier,
              /* y */ req_offset + (15 * modifier))
        req_offset += 12 * modifier;

        // REQ STR
        renderReqNumber(getFieldValueById('reqSTR'), ctx, 
              /* x */ 144 * modifier,
              /* y */ req_offset + (15 * modifier))
        req_offset += 12 * modifier;

        // REQ DEX
        renderReqNumber(getFieldValueById('reqDEX'), ctx, 
              /* x */ 144 * modifier,
              /* y */ req_offset + (15 * modifier))
        req_offset += 12 * modifier;

        // REQ INT
        renderReqNumber(getFieldValueById('reqINT'), ctx, 
              /* x */ 144 * modifier,
              /* y */ req_offset + (15 * modifier))
        req_offset += 12 * modifier;

        // REQ LUK
        renderReqNumber(getFieldValueById('reqLUK'), ctx, 
              /* x */ 144 * modifier,
              /* y */ req_offset + (15 * modifier))
        req_offset += 12 * modifier;
        // REQ FAME (TODO - NOT SUPPORTED YET)
        renderReqNumber(0, ctx, 
              /* x */ 144 * modifier,
              /* y */ req_offset + (15 * modifier))

        itemImagePromise.then((itemImage) => {
        ctx.drawImage(itemImage,
                        (45 - (itemImage.width/2)) * modifier,
                        offset + (47 - (itemImage.height/2)) * modifier,
                        itemImage.width  * modifier,
                        itemImage.height  * modifier);
        });


        // CLASSES INDICATORS
        do_classes((116 * modifier) + offset);
        
        // WHITE SEPARATOR LINE -- OLD CODE. Now written in dynamic area
        // ctx.fillStyle = 'white';
        // ctx.fillRect(6 * modifier, (135 * modifier) + offset, canvas.width - (12 * modifier), 1 * modifier); 

        // Write DESCRIPTION (bottom area)
        // Set the initial Y coordinate
        let lineY = 142 * modifier + offset;
        // Iterate through the textLines array and draw each line
        //ctx.translate(0.5, 0.5);
        textLines.forEach(line => {
            let fontSize = 9 * modifier;
            ctx.font = `${fontSize}px Arial`;
            ctx.fillStyle = '#ffeecc'
            // Draw the label
            let label_x = 18 * modifier;

            
            if (line.label.startsWith("---"))
            {
              // HACK TO DRAW A SEPARATOR LINE INSTEAD OF A FIELD
              ctx.fillStyle = 'white';
              ctx.fillRect(6 * modifier, lineY - (7 * modifier), canvas.width - (12 * modifier), 1 * modifier); 

              // Update the Y coordinate for the next line
              lineY += 9 * modifier; // You can adjust the spacing between lines as needed
            }
            else {
                // DRAW A REGULAR FIELD
                ctx.fillText(line.label, label_x, lineY);
                // Draw the value
                ctx.fillStyle = 'white'
                ctx.font = `bold ${line.fontSize}px Arial`;
                let labelWidth = Math.ceil(ctx.measureText(line.label).width);
                let valX = label_x + labelWidth + (2 * modifier);
                
                if(!renderStatValue(line.value, ctx, valX, lineY - (8 * modifier))) {
                  ctx.fillText(line.value, valX, lineY); // Adjust the X coordinate as needed
                }
                
                // Draw little orange plus before label
                ctx.font = 'bold ' + (6 * modifier) + 'px Arial';
                ctx.fillStyle = '#FF6600'
                ctx.translate(0.5, 0.5);
                ctx.fillText("+", 9 * modifier, lineY - 2);
                ctx.translate(-0.5, -0.5);
                
                // Update the Y coordinate for the next line
                lineY += 13 * modifier; // You can adjust the spacing between lines as needed
            }
          });




          function drawText(context, text, x, y, fontSize, fontFamily, color) {
            // Create an off-screen canvas
            var offScreenCanvas = document.createElement('canvas');
            var offScreenContext = offScreenCanvas.getContext('2d');

            // Set the off-screen canvas size
            offScreenCanvas.width = context.canvas.width;
            offScreenCanvas.height = context.canvas.height;

            // Set anti-aliasing to "none" on the off-screen context
            offScreenContext.imageSmoothingEnabled = true;

            // Draw text on the off-screen canvas
            offScreenContext.font = (fontSize) + 'px ' + fontFamily;
            offScreenContext.fillStyle = color;
            for (let i = 0; i < 500; i++) {
              offScreenContext.fillText(text, x, y);
            }
            

            // Draw the off-screen canvas onto the main canvas
            context.drawImage(offScreenCanvas, 0, 0);
          }

        };
      



      function load(itemNumber)
      {
      // URL of the JSON endpoint (replace with the actual URL)
      const apiUrl = 'https://maplestory.io/api/GMS/207.1.1/item/' + itemNumber;

      // Make a GET request to fetch the JSON data
      fetch(apiUrl)
        .then(response => {
          if (!response.ok) {
            throw new Error(`Network response was not ok: ${response.status}`);
          }
          return response.json();
        })
        .then(data => {  
          // Do something with the name, for example, log it to the console
          console.log(`Name: ${name}`);
          updateFieldsFromJson(data);
          redraw();
        })
        .catch(error => {
          // Handle errors during the fetch operation
          console.error('Fetch error:', error);
        });
      }

    // Function to be called when the button is pressed
    function loadData() {
      // Get the value from the textbox
      var inputValue = document.getElementById("myTextbox").value;
      // Call the "load" function with the textbox value as a parameter
      load(inputValue);
    }
    
    loadReqDigits().then(()=> {
        req = stat;
        loadStatDigits().then(()=> loadData());
      }
    );

    function composeFields() {
      const textLines = [];
      // Get all elements with the class "input-pair"
      const inputPairs = document.getElementsByClassName("input-pair");
      // Iterate over the input pairs
      for (let i = 0; i < inputPairs.length; i++) {
        const labelInput = inputPairs[i].querySelector('.label-input');
        const checkboxInput = inputPairs[i].querySelector('.checkbox-input');
        const valueInput = inputPairs[i].querySelector('.value-input');
        const label = labelInput.value +" : ";
        const value = valueInput.value;
        // Check if checkboxInput is defined before accessing its properties
        const isChecked = checkboxInput ? checkboxInput.checked : true;
        // Add the line only if the checkbox is checked
        if (isChecked) {
          textLines.push({ label, value });
        }
      }
      // Display the resulting textLines array in the console (you can replace this with your actual logic)
      return textLines;
    }
  </script>
</body>
</html>
